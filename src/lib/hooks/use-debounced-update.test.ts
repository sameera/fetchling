// Generated by Gemini
import { act, renderHook } from "@testing-library/react";
import { afterEach, beforeEach, describe, expect, it, vi } from "vitest";

import type { ResourceAPI } from "../types";

import { useDebouncedUpdate } from "./use-debounced-update";

// Mock the part of the ResourceAPI that is used by the hook
const mockResource: Pick<ResourceAPI<any, any>, "table" | "update"> = {
    table: {
        get: vi.fn(),
        put: vi.fn(),
    },
    update: vi.fn(),
};

describe("useDebouncedUpdate", () => {
    const debounceMs = 500;
    const simpleId = { id: "test-id-1" };
    const compositeId = { userId: "user-1", noteId: "note-5" };
    const initialData = { content: "hello" };
    const updatedData = { content: "hello world" };

    beforeEach(() => {
        vi.useFakeTimers();
        vi.spyOn(console, "error").mockImplementation(() => {});
        vi.clearAllTimers();
        mockResource.update.mockClear();
        mockResource.table.get.mockClear();
        mockResource.table.put.mockClear();
        mockResource.update.mockResolvedValue(undefined); // Ensure it returns a promise
    });

    afterEach(() => {
        vi.useRealTimers();
        vi.clearAllMocks();
        (console.error as vi.Mock).mockRestore();
    });

    it("should save to IndexedDB immediately but not sync to API", async () => {
        const { result } = renderHook(() =>
            useDebouncedUpdate(mockResource as any, debounceMs)
        );

        await act(async () => {
            await result.current.debouncedUpdate(simpleId, initialData);
        });

        expect(mockResource.table.get).toHaveBeenCalledWith(simpleId);
        expect(mockResource.table.put).toHaveBeenCalledTimes(1);
        expect(mockResource.table.put).toHaveBeenCalledWith({ ...initialData, id: simpleId });
        expect(mockResource.update).not.toHaveBeenCalled();
    });

    it("should sync to API after the debounce delay", async () => {
        const { result } = renderHook(() =>
            useDebouncedUpdate(mockResource as any, debounceMs)
        );

        await act(async () => {
            await result.current.debouncedUpdate(simpleId, initialData);
        });

        expect(mockResource.update).not.toHaveBeenCalled();

        await act(async () => {
            vi.advanceTimersByTime(debounceMs);
        });

        expect(mockResource.update).toHaveBeenCalledTimes(1);
        expect(mockResource.update).toHaveBeenCalledWith(simpleId, initialData);
    });

    it("should debounce multiple updates into a single API call with the latest data", async () => {
        const { result } = renderHook(() =>
            useDebouncedUpdate(mockResource as any, debounceMs)
        );

        await act(async () => {
            await result.current.debouncedUpdate(simpleId, initialData);
        });

        await act(async () => {
            vi.advanceTimersByTime(debounceMs - 100);
            await result.current.debouncedUpdate(simpleId, updatedData);
        });

        expect(mockResource.table.put).toHaveBeenCalledTimes(2);
        expect(mockResource.update).not.toHaveBeenCalled();

        await act(async () => {
            vi.advanceTimersByTime(debounceMs);
        });

        expect(mockResource.update).toHaveBeenCalledTimes(1);
        expect(mockResource.update).toHaveBeenCalledWith(simpleId, updatedData);
    });

    it("should merge updates with an existing entity in IndexedDB", async () => {
        const existingEntity = { content: "original", version: 1, id: simpleId };
        const partialUpdate = { content: "updated" };
        const expectedMergedEntity = { ...existingEntity, ...partialUpdate };
        (mockResource.table.get as vi.Mock).mockResolvedValue(existingEntity);

        const { result } = renderHook(() =>
            useDebouncedUpdate(mockResource as any, debounceMs)
        );

        await act(async () => {
            await result.current.debouncedUpdate(simpleId, partialUpdate);
        });

        expect(mockResource.table.get).toHaveBeenCalledWith(simpleId);
        expect(mockResource.table.put).toHaveBeenCalledWith(
            expectedMergedEntity
        );
    });

    it("should create a new entity in IndexedDB if one does not exist", async () => {
        const expectedEntity = { ...initialData, id: simpleId };
        (mockResource.table.get as vi.Mock).mockResolvedValue(undefined);

        const { result } = renderHook(() =>
            useDebouncedUpdate(mockResource as any, debounceMs)
        );

        await act(async () => {
            await result.current.debouncedUpdate(simpleId, initialData);
        });

        expect(mockResource.table.get).toHaveBeenCalledWith(simpleId);
        expect(mockResource.table.put).toHaveBeenCalledWith(expectedEntity);
    });

    it("should handle composite keys correctly", async () => {
        const expectedEntity = { ...initialData, id: compositeId };
        (mockResource.table.get as vi.Mock).mockResolvedValue(undefined);

        const { result } = renderHook(() =>
            useDebouncedUpdate(mockResource as any, debounceMs)
        );

        await act(async () => {
            await result.current.debouncedUpdate(compositeId, initialData);
        });

        expect(mockResource.table.get).toHaveBeenCalledWith(compositeId);
        expect(mockResource.table.put).toHaveBeenCalledWith(expectedEntity);

        await act(async () => {
            vi.advanceTimersByTime(debounceMs);
        });

        expect(mockResource.update).toHaveBeenCalledWith(
            compositeId,
            initialData
        );
    });

    it("should flush a pending update immediately", async () => {
        const { result } = renderHook(() =>
            useDebouncedUpdate(mockResource as any, debounceMs)
        );

        await act(async () => {
            await result.current.debouncedUpdate(simpleId, initialData);
        });

        expect(mockResource.update).not.toHaveBeenCalled();

        await act(async () => {
            await result.current.flush();
        });

        expect(mockResource.update).toHaveBeenCalledTimes(1);
        expect(mockResource.update).toHaveBeenCalledWith(simpleId, initialData);

        // Advancing timer should not trigger another call
        await act(async () => {
            vi.advanceTimersByTime(debounceMs);
        });
        expect(mockResource.update).toHaveBeenCalledTimes(1);
    });

    it("flush should do nothing if there is no pending update", async () => {
        const { result } = renderHook(() =>
            useDebouncedUpdate(mockResource as any, debounceMs)
        );

        await act(async () => {
            await result.current.flush();
        });

        expect(mockResource.update).not.toHaveBeenCalled();
    });

    it("should cancel a pending update", async () => {
        const { result } = renderHook(() =>
            useDebouncedUpdate(mockResource as any, debounceMs)
        );

        await act(async () => {
            await result.current.debouncedUpdate(simpleId, initialData);
        });

        act(() => {
            result.current.cancel();
        });

        await act(async () => {
            vi.advanceTimersByTime(debounceMs);
        });

        expect(mockResource.update).not.toHaveBeenCalled();
    });

    it("should auto-flush on unmount", async () => {
        const { result, unmount } = renderHook(() =>
            useDebouncedUpdate(mockResource as any, debounceMs)
        );

        await act(async () => {
            await result.current.debouncedUpdate(simpleId, initialData);
        });

        expect(mockResource.update).not.toHaveBeenCalled();

        act(() => {
            unmount();
        });

        expect(mockResource.update).toHaveBeenCalledTimes(1);
        expect(mockResource.update).toHaveBeenCalledWith(simpleId, initialData);
    });

    it("should log error but not throw if IndexedDB save fails", async () => {
        const testError = new Error("DB Save Failed");
        (mockResource.table.put as vi.Mock).mockRejectedValue(testError);

        const { result } = renderHook(() =>
            useDebouncedUpdate(mockResource as any, debounceMs)
        );

        await act(async () => {
            await result.current.debouncedUpdate(simpleId, initialData);
        });

        expect(console.error).toHaveBeenCalledWith(
            "[useDebouncedUpdate] Failed to save to IndexedDB:",
            testError
        );

        // API call should still be scheduled
        await act(async () => {
            vi.advanceTimersByTime(debounceMs);
        });
        expect(mockResource.update).toHaveBeenCalledTimes(1);
    });

    it("should log error but not throw if API sync fails", async () => {
        const testError = new Error("API Sync Failed");
        (mockResource.update as vi.Mock).mockRejectedValue(testError);

        const { result } = renderHook(() =>
            useDebouncedUpdate(mockResource as any, debounceMs)
        );

        await act(async () => {
            await result.current.debouncedUpdate(simpleId, initialData);
        });

        await act(async () => {
            vi.advanceTimersByTime(debounceMs);
        });

        expect(console.error).toHaveBeenCalledWith(
            "[useDebouncedUpdate] Failed to sync to API:",
            testError
        );
    });

    it("flush should wait for an in-flight API call to complete", async () => {
        let resolveApiCall: (value: unknown) => void;
        const apiPromise = new Promise((resolve) => {
            resolveApiCall = resolve;
        });
        (mockResource.update as vi.Mock).mockReturnValue(apiPromise);

        const { result } = renderHook(() =>
            useDebouncedUpdate(mockResource as any, debounceMs)
        );

        // Start a debounced update and trigger the API call
        await act(async () => {
            await result.current.debouncedUpdate(simpleId, initialData);
            vi.advanceTimersByTime(debounceMs); // This should trigger syncToAPI and set apiCallRef.current
        });

        expect(mockResource.update).toHaveBeenCalledTimes(1);

        let flushFinished = false;
        const flushPromise = result.current.flush().then(() => {
            flushFinished = true;
        });

        // flush should not be finished yet because apiPromise is still pending.
        expect(flushFinished).toBe(false);

        // Resolve the API call
        await act(async () => {
            resolveApiCall({});
            await apiPromise; // Ensure the promise chain completes
        });

        // Now flush should be finished
        await act(async () => {
            await flushPromise;
        });
        expect(flushFinished).toBe(true);
    });
});
